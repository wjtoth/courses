\section{Matchings}\label{sec:matching}
\paragraph{}
In a {\it maximum matching problem} we are given a graph $G=(V,E)$ and asked for find  $M\subseteq E$, maximizing $|M|$, such that every vertex of $(V,M)$ has degree at most $1$. \subsection{Bipartite Matching}
\paragraph{}
A {\it bipartite graph} is a graph where there exists a partition $A\cup B = V$ such that no vertices in $A$ are adjacent, and no vertices in $B$ are adjacent. A well known equivalent definition of a bipartite graph is one with no odd cycles. In bipartite graphs the best known classical algorithm takes time $O(n^\omega)$ \cite{mucha2004maximum} where $2\leq\omega\leq 2.4$ is the matrix multiplication constant and $n = |V|$, with the caveat that if $\omega = 2$ then algorithm a $\log n$ factor appears in the runtime.  Our quantum algorithm is inspired by the $O(n^{5/2})$-time classical algorithm in \cite{hopkroft1973n5}.
\paragraph{}
As in our study of Network Flows we will identify a notion of augmenting paths we can use to improve our matchings, and a residual graph structure which enables easy identification of such paths. For a graph $G$ and a matching $M$, we say a path $P$ in $G$ is {\it $M$-augmenting} if the endpoints of $P$ are not matched in $M$ and the edges of $P$ are alternately not in $M$ and in $M$. If we have such $P$ we can flip the matched edges in $M$ along $P$ (formally we replace $M$ with the symmetric difference of $M$ and $P$) to obtain a matching of larger size than $M$.
\paragraph{}
In bipartite graphs $M$-augmenting paths can easily be found using a {\it residual graph} structure. Construct a directed graph $H$ based on $G$ and $M$ as follows. The vertex set of $H$ is $A\cup B\cup \{r,s\}$ with source $r$ and sink $s$. For each edge $ab \in E$ with $a \in A$ and $b\in B$,  add arc $(a,b)$ to $H$ if $ab \not\in M$, otherwise add arc $(b,a)$. For each $a \in A$ that is not matched by $M$ add arc $(r,a)$ to $H$. Similarly for each $b \in B$ unmatched by $M$ add arc $(b,s)$. Now it is not hard to see that $r$-$s$ dipaths in $H$ correspond to $M$-augmenting paths in $G$.
\paragraph{Algorithm}
Our quantum algorithm for bipartite maximum matching is as follows:
\begin{enumerate}
\item Set $M = \emptyset$
\item  Let $H$ be the residual graph with respect to $G$ and $M$. Compute a layering $\ell$ for $H$.
\item Find by depth-first Grovers Search using $\ell$ a maximal set $S$ of vertex-disjoint $r$-$s$ paths in $H$.
\item Augment $M$ by all paths in $S$. Note such paths all have the same minimal length.
\item If $S\neq \emptyset$ Return to Step $2$. Otherwise output $M$ and quit.
\end{enumerate} 
\begin{theorem}
Our quantum algorithm finds a maximum bipartite matching in expected time $O(n\sqrt{m+n}\log n)$ in the list model and $O(n^2\log n)$ in the adjacency model.
\end{theorem}
\begin{proof}
First we bound the number of iterations of Step $2$ in the algorithm. Let $s$ be the size of a maximal matching $M$ in $G$ and let $s_i$ be the size of matching found by the algorithm after iteration $i$.  Let $j$ be the first iteration with $s_j \geq s-\sqrt{n}$. Since the algorithm finds at least one augmenting path each time it runs from Step $2$, there are at most $\sqrt{n}$ iterations remaining after iteration $j$.  Now in \cite{hopkroft1973n5} they give the following Lemma
\begin{align*}&\text{If $M_1$ and $M_2$ are matchings of size $s_1$ and $s_2$ respectively ($s_1 < s_2$)}\\&\text{then there exist $s_2-s_1$ vertex disjoint $M_1$-augmenting paths.}\end{align*}
Applying this Lemma with $M_1 = M_j$ and $M_2 = M$ we see there are at least $\sqrt{n}$ vertex disjoint $M_j$-augmenting paths. Since the length of $M_i$-augmenting paths increase by one each iteration, the length of these $M_j$-augmenting paths is at least $j+2$. So therefore we have $j <\sqrt{n}$, and hence the total number of iterations of Step $2$ is at most $2\sqrt{n} = O(\sqrt{n})$.
\paragraph{Bounding Time to Find all Augmenting Paths}
We will show the bound for the adjacency model. The bounds for the list model follow by similar arguments, using as well the bounding techniques of the proof of Theorem \ref{th:layering}. The layer numbers for $H$ can be computed in time $O(n^{3/2}\log n)$ in the adjacency model by Theorem \ref{th:layering}. Our depth-first search proceeds from a vertex by searching all vertices with layer number $\ell$ one greater to find a descendant. Each vertex will thus join an augmenting path and be marked, or it does not belong to any such path. Each vertex is thus visited at most once and hence costs expected $O(\sqrt{n})$ time to be found and another $O(\sqrt{n})$ time to decide it has no remaining descendants. Therefore the desired runtime bound holds.
\end{proof}
\bigskip
\paragraph{Lower Bounds}
In \cite{boyer1996tight} and \cite{zhang2005power} they demonstrate the existence of a quantum adversary for maximum bipartite matching implying a $\Omega(n^{3/2})$ quantum query complexity lower bound for the problem. Since this is a special case of both general matching (to follow), and the network flow problem studied in the previous Section it provides a lower bound for those problems as well.
\subsection{General Matching}
\paragraph{}
Our general quantum matching algorithm follows the classic Blossom algorithm of Edmonds \cite{edmonds1965paths}. An excellent reference for this algorithm is Chapter $5$ of the textbook Combinatorial Optimization by Cook, Cunningham, Pulleyblank, and Schrijver \cite{cook2009combinatorial}. In broad strokes the algorithm starts with an empty matching $M$ and in each iteration identifies either an augmenting path, an odd circuit with one $M$-exposed vertex, or decides the matching is maximum and terminates. In the first case $M$ is augmented by the path found, and in the second the odd circuit is contracted to a single vertex and the algorithm proceeds on the resulting subgraph.
\paragraph{}
It can be shown that classically the Blossom algorithm can be implemented in time $O(nm\log n)$. The quantum algorithm presented in \cite{ambainis2006quantum} follows the same framework as the Blossom algorithm but speeds up all necessary searching by using Grovers Search. In every iteration of Blossom we have an exposed vertex $r$ and build a tree of vertices by breadth-first search which lie on alternating paths from $r$. Each vertex that lies on an even length path from $r$ in the tree is of interest. If an even vertex $v$ has an exposed neighbour then we have found an augmenting path. If it has an $M$-covered neighbour then we can either extend the tree or identify an odd circuit. These situations lead to three instances of Grover's Search at $v$ taking total expected time $O(\sqrt{nm})$.  This discussion leads to the following theorem, a detail proof of which is found in the source material.
\begin{theorem}
A maximum matching can be found with a quantum computer in expected time $O(n^2(\sqrt{m/n} + \log n))$ in the list model and $O(n^{5/2}\log n)$ in the adjacency model.
\end{theorem}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     